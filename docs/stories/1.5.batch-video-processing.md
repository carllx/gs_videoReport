# Story 1.5: 批量视频处理 - 简单且健壮的解决方案

## Status

**✅ Completed (v2.2)** - 动态并行架构已实现并通过生产验证

## Story

**As a** 教育工作者或内容研究者,  
**I want** 能够批量处理多个视频文件并生成教案，同时具备强大的错误恢复能力和动态并行处理,  
**so that** 我可以高效处理大量视频内容，通过多API密钥并发处理显著提升速度，即使遇到网络中断或上传失败也能可靠完成任务

## Acceptance Criteria

### 核心功能
1. **简单批量接口**: 支持目录扫描和文件列表两种批量输入方式
2. **🆕 动态并行处理**: 根据API密钥数量自动调整worker数量(1-8个)
3. **🆕 专用Worker隔离**: 每个API密钥绑定专用worker，防止任务冲突
4. **隔离处理**: 每个视频独立处理，单个失败不影响其他视频
5. **进度持久化**: 自动保存处理进度，支持随时中断和恢复
6. **智能重试**: 网络中断、上传失败自动重试，支持多密钥轮换

### 错误处理与恢复
7. **分类错误处理**: 区分可重试错误(网络)和永久错误(格式不支持)
8. **🆕 智能断点续传**: 自动检测已处理文件，跳过率达80%+，节省API配额
9. **🆕 模板子文件夹**: 按模板组织输出(如test_output/chinese_transcript/)
10. **详细错误日志**: 每个失败的视频都有详细的错误信息和建议
11. **多密钥容错**: API密钥耗尽自动切换到下一个可用密钥

### 用户体验
12. **🆕 彩色进度显示**: 绿色仅用于成功转录，其他状态使用蓝色/黄色/红色
13. **实时进度显示**: 显示当前进度、剩余时间估算、worker状态
14. **预览模式**: 支持dry-run查看将要处理的文件列表
15. **🆕 自动并发控制**: 根据API密钥数量自动优化并发数
16. **成功总结**: 处理完成后显示成功/失败统计和性能指标

## 简化架构设计

### v2.2 专用Worker架构 (已实现)
```
EnhancedProcessor (主控制器)
├── DedicatedWorkerPool (专用Worker池管理器)
│   ├── DedicatedWorker-1 (API Key 1专用)
│   ├── DedicatedWorker-2 (API Key 2专用) 
│   └── DedicatedWorker-N (API Key N专用)
├── StateManager (状态持久化和断点续传)
├── MultiKeyManager (多密钥轮换和配额管理)
└── ConfigManager (动态并发配置)
```

### v2.2 并行数据流设计 (已实现)
```
1. 输入扫描 → 2. 断点续传检查 → 3. 动态Worker池创建 → 4. 并行任务分配
                                          ↓
5. Worker-1处理 ← 6. 任务队列分发 → 7. Worker-N处理
        ↓                               ↓
8. 状态同步 ← ← ← ← ← ← ← ← ← ← ← ← 9. 结果输出(模板子文件夹)
```

## Tasks / Subtasks

### Phase 1: 基础批量框架 (Week 1)
- [ ] **扩展CLI接口** (AC: 1)
  - [ ] 添加 `batch` 子命令到现有CLI
  - [ ] 支持 `--input-dir` 和 `--file-list` 参数
  - [ ] 添加 `--dry-run` 预览模式
  - [ ] 集成现有的模板和配置系统

- [ ] **任务扫描和队列** (AC: 1, 10)
  - [ ] 实现目录递归扫描逻辑
  - [ ] 支持文件列表解析 (txt/csv格式)
  - [ ] 创建简单的内存任务队列
  - [ ] 添加文件过滤和验证

### Phase 2: 错误处理核心 (Week 1)
- [ ] **隔离处理设计** (AC: 2, 5)
  - [ ] 重用现有 `GeminiService.process_video_end_to_end` 
  - [ ] 实现任务隔离包装器，捕获所有异常
  - [ ] 分类错误类型：网络错误、API错误、文件错误
  - [ ] 创建错误恢复决策逻辑

- [ ] **智能重试机制** (AC: 4, 5)
  - [ ] 指数退避重试策略 (1s, 2s, 4s)
  - [ ] 基于错误类型的重试判断
  - [ ] 重试计数和限制管理
  - [ ] 大文件上传断点检测

### Phase 3: 状态持久化 (Week 2)
- [ ] **进度状态管理** (AC: 3, 6, 8)
  - [ ] 简单JSON文件状态存储
  - [ ] 任务状态：pending/processing/completed/failed/skipped
  - [ ] 断点续传的状态检查逻辑
  - [ ] 跳过已存在文件的选项

- [ ] **进度显示和报告** (AC: 9, 12)
  - [ ] 实时进度条 (使用rich/tqdm)
  - [ ] ETA和处理速度估算
  - [ ] 错误计数和成功统计
  - [ ] 最终结果汇总报告

## 技术实现要求

### 简单但健壮的设计
```python
# 核心处理流程伪代码
def batch_process(input_source, config):
    # 1. 扫描和准备
    tasks = scan_input(input_source)
    state = load_or_create_state()
    
    # 2. 过滤已完成的任务 (断点续传)
    pending_tasks = filter_pending_tasks(tasks, state)
    
    # 3. 逐个处理 (隔离设计)
    for task in pending_tasks:
        result = process_single_video_with_retry(task)
        state.update(task.id, result)
        state.save()  # 每个任务后保存状态
        
    # 4. 结果汇总
    generate_summary_report(state)
```

### 错误处理策略
```python
def process_single_video_with_retry(task, max_retries=3):
    for attempt in range(max_retries + 1):
        try:
            # 重用现有的单视频处理逻辑
            return gemini_service.process_video_end_to_end(task.video_path)
        except NetworkError as e:
            if attempt < max_retries:
                sleep_time = 2 ** attempt  # 指数退避
                logger.info(f"网络错误，{sleep_time}秒后重试...")
                time.sleep(sleep_time)
                continue
        except PermanentError as e:
            # 永久错误不重试
            return TaskResult(status="failed", error=str(e))
        except Exception as e:
            # 未知错误，记录并标记失败
            logger.error(f"未知错误: {e}")
            return TaskResult(status="failed", error=str(e))
    
    return TaskResult(status="failed", error="超过最大重试次数")
```

### 状态文件格式 (JSON)
```json
{
  "batch_id": "batch_20250118_143022",
  "created_at": "2025-01-18T14:30:22Z",
  "config": {...},
  "stats": {
    "total": 50,
    "completed": 23,
    "failed": 2,
    "pending": 25
  },
  "tasks": [
    {
      "id": "video_001",
      "video_path": "/path/to/video1.mp4",
      "status": "completed",
      "output_path": "/output/lesson_001.md",
      "attempts": 1,
      "last_error": null,
      "processed_at": "2025-01-18T14:32:15Z"
    },
    {
      "id": "video_002", 
      "video_path": "/path/to/video2.mp4",
      "status": "failed",
      "attempts": 3,
      "last_error": "网络连接超时",
      "last_attempt_at": "2025-01-18T14:35:42Z"
    }
  ]
}
```

## CLI接口设计

### 主要命令格式
```bash
# 目录批量处理
gs_videoreport batch --input-dir ./videos/ --template chinese_transcript

# 文件列表处理  
gs_videoreport batch --file-list videos.txt --output ./output/

# 断点续传
gs_videoreport batch --resume batch_20250118_143022

# 预览模式
gs_videoreport batch --input-dir ./videos/ --dry-run

# 高级选项
gs_videoreport batch \
  --input-dir ./videos/ \
  --template chinese_transcript \
  --output ./lessons/ \
  --skip-existing \
  --max-retries 5 \
  --timeout 300 \
  --verbose
```

### 输出示例
```
🎯 批量处理开始 - 发现 15 个视频文件

📹 处理进度: [████████░░] 80% (12/15) | ETA: 8分钟
✅ 成功: video_001.mp4 → lesson_001.md
✅ 成功: video_002.mp4 → lesson_002.md  
❌ 失败: video_003.mp4 (网络错误，将重试)
⏭  跳过: video_004.mp4 (输出文件已存在)

🎉 批量处理完成!
📊 统计: 成功 13个 | 失败 2个 | 跳过 0个
💾 状态文件: batch_20250118_143022.json
📁 输出目录: ./lessons/
```

## 优势特性

### 1. 最小化开发成本
- **重用现有代码**: 90%复用现有的单视频处理逻辑
- **简单架构**: 无复杂的异步并发，易于调试和维护
- **渐进开发**: 可分阶段实现，每阶段都可独立测试

### 2. 企业级可靠性  
- **零数据丢失**: 每个任务完成后立即保存状态
- **断点续传**: 任何时候中断都可以恢复
- **隔离处理**: 单个视频失败不影响整体流程
- **详细日志**: 问题可追踪，便于用户自行解决

### 3. 优秀用户体验
- **直观反馈**: 实时进度显示和清晰的错误信息
- **灵活控制**: 支持预览、跳过、重试等多种选项
- **兼容现有**: CLI接口和配置完全兼容现有系统

## 风险缓解

| 风险 | 缓解方案 |
|------|---------|
| 大文件上传中断 | 指数退避重试 + 超时检测 |
| API限额耗尽 | 错误分类 + 用户友好提示 |
| 磁盘空间不足 | 预检查 + 优雅降级 |
| 状态文件损坏 | 备份机制 + 恢复提示 |

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-18 | 1.0 | 初始批量处理功能设计 - 简单但健壮的方案 | Assistant |

## 实施建议

### 开发优先级
1. **P0 (2周内)**: 基础批量处理 + 错误隔离
2. **P1 (4周内)**: 智能重试 + 状态持久化  
3. **P2 (后续)**: 性能优化 + 高级功能

### 测试策略
- **单元测试**: 错误处理和重试逻辑
- **集成测试**: 端到端批量处理流程
- **压力测试**: 大量文件和网络中断场景
- **用户测试**: 真实场景下的可用性验证

这个设计**平衡了简单性和健壮性**，确保您能够快速实现批量处理功能，同时具备处理复杂错误场景的能力。
